diff --git a/Ghidra/Features/Decompiler/buildNatives.gradle b/Ghidra/Features/Decompiler/buildNatives.gradle
index e0dfb2fa3f..a2bd5dea5f 100644
--- a/Ghidra/Features/Decompiler/buildNatives.gradle
+++ b/Ghidra/Features/Decompiler/buildNatives.gradle
@@ -96,6 +96,9 @@ model {
 		                include "funcdata_op.cc"
 		                include "pcodeinject.cc"
 		                include "heritage.cc"
+		                include "multiequal_trace.cc"
+		                include "decompiler_fixes.cc"
+		                include "decompiler_fixes_cmd.cc"
 		                include "prefersplit.cc"
 		                include "rangeutil.cc"
 		                include "ruleaction.cc"
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/decomp_dbg.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/decomp_dbg.hh
new file mode 100644
index 0000000000..3dcb930f3e
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/decomp_dbg.hh
@@ -0,0 +1,52 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/// \file decomp_dbg.hh
+/// \brief Simple unbuffered file logging for decompiler debugging
+///
+/// This header provides debug logging macros for the decompiler.
+/// Define DECOMP_DEBUG_ENABLED to enable logging to /tmp/decomp_debug.log
+
+#ifndef __DECOMP_DBG_HH__
+#define __DECOMP_DBG_HH__
+
+// Uncomment to enable debug logging
+// #define DECOMP_DEBUG_ENABLED
+
+#ifdef DECOMP_DEBUG_ENABLED
+
+#include <fstream>
+#include <sstream>
+
+/// Get unbuffered log file stream
+inline std::ofstream& getDecompLog() {
+  static std::ofstream logfile("/tmp/decomp_debug.log", std::ios::app);
+  logfile << std::unitbuf;  // Unbuffered for immediate writes
+  return logfile;
+}
+
+#define DECOMP_LOG(msg) do { \
+  std::ostringstream _oss; \
+  _oss << msg; \
+  getDecompLog() << _oss.str() << "\n"; \
+} while(0)
+
+#else
+
+#define DECOMP_LOG(msg) ((void)0)
+
+#endif
+
+#endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes.cc
new file mode 100644
index 0000000000..f95aad9faf
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes.cc
@@ -0,0 +1,66 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/// \file decompiler_fixes.cc
+/// \brief Implementation of per-function decompiler fixes registry
+
+#include "decompiler_fixes.hh"
+#include <map>
+
+namespace ghidra {
+
+/// Static map of function addresses to their enabled fix flags
+static std::map<uint8, uint4> fixRegistry;
+
+void DecompilerFixes::registerFixes(uint8 addr, uint4 flags)
+{
+  fixRegistry[addr] = flags;
+}
+
+void DecompilerFixes::addFixes(uint8 addr, uint4 flags)
+{
+  fixRegistry[addr] |= flags;
+}
+
+void DecompilerFixes::clearAll()
+{
+  fixRegistry.clear();
+}
+
+void DecompilerFixes::clearAddress(uint8 addr)
+{
+  fixRegistry.erase(addr);
+}
+
+uint4 DecompilerFixes::getFixes(uint8 addr)
+{
+  auto it = fixRegistry.find(addr);
+  if (it != fixRegistry.end()) {
+    return it->second;
+  }
+  return DFIX_NONE;
+}
+
+bool DecompilerFixes::hasFix(uint8 addr, DecompilerFixFlags flag)
+{
+  return (getFixes(addr) & flag) != 0;
+}
+
+bool DecompilerFixes::hasRegisteredAddresses()
+{
+  return !fixRegistry.empty();
+}
+
+}
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes.hh
new file mode 100644
index 0000000000..3c06db25ac
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes.hh
@@ -0,0 +1,77 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/// \file decompiler_fixes.hh
+/// \brief Registry for enabling per-function decompiler fixes
+
+#ifndef __DECOMPILER_FIXES_HH__
+#define __DECOMPILER_FIXES_HH__
+
+#include "types.h"
+
+namespace ghidra {
+
+/// \brief Flags for different decompiler fixes that can be enabled per-function
+enum DecompilerFixFlags {
+  DFIX_NONE = 0,
+  DFIX_MULTIEQUAL_STACK_TRACE = 1 << 0,  ///< Trace MULTIEQUAL inputs for precise stack offsets
+  // Future fixes can be added here:
+  // DFIX_FUTURE_FIX_1 = 1 << 1,
+  // DFIX_FUTURE_FIX_2 = 1 << 2,
+};
+
+/// \brief Registry for per-function decompiler fixes
+///
+/// This provides per-function control over various decompiler fixes and enhancements.
+/// Functions can be registered with specific fix flags before decompilation, and
+/// the decompiler checks this registry to decide which fixes to apply.
+class DecompilerFixes {
+public:
+  /// Register a function address with specific fix flags
+  /// \param addr is the function entry address
+  /// \param flags is the bitmask of fixes to enable
+  static void registerFixes(uint8 addr, uint4 flags);
+
+  /// Add fix flags to an already registered address (or register if new)
+  /// \param addr is the function entry address
+  /// \param flags is the bitmask of fixes to add
+  static void addFixes(uint8 addr, uint4 flags);
+
+  /// Clear all registered addresses
+  static void clearAll();
+
+  /// Clear fixes for a specific address
+  /// \param addr is the function entry address
+  static void clearAddress(uint8 addr);
+
+  /// Get the fix flags for a function
+  /// \param addr is the function entry address
+  /// \return the bitmask of enabled fixes (0 if not registered)
+  static uint4 getFixes(uint8 addr);
+
+  /// Check if a specific fix is enabled for a function
+  /// \param addr is the function entry address
+  /// \param flag is the fix flag to check
+  /// \return true if the fix is enabled
+  static bool hasFix(uint8 addr, DecompilerFixFlags flag);
+
+  /// Check if any addresses are registered
+  /// \return true if at least one address is registered
+  static bool hasRegisteredAddresses();
+};
+
+}
+
+#endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes_cmd.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes_cmd.cc
new file mode 100644
index 0000000000..af2ebfc487
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/decompiler_fixes_cmd.cc
@@ -0,0 +1,128 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/// \file decompiler_fixes_cmd.cc
+/// \brief Implementation of GhidraCommands for per-function decompiler fixes
+
+#include "ghidra_process.hh"
+#include "decompiler_fixes.hh"
+
+namespace ghidra {
+
+/// Load parameters for SetDecompilerFixes - reads flags and address list
+/// Does not require an Architecture - operates on global registry
+void SetDecompilerFixes::loadParameters(void)
+
+{
+  // Read and ignore arch id (for protocol compatibility)
+  int4 type = ArchitectureGhidra::readToAnyBurst(sin);
+  if (type != 14)
+    throw JavaError("alignment", "Expecting arch id start");
+  int4 ignoredId;
+  sin >> dec >> ignoredId;
+  type = ArchitectureGhidra::readToAnyBurst(sin);
+  if (type != 15)
+    throw JavaError("alignment", "Expecting arch id end");
+
+  // Read flags value
+  type = ArchitectureGhidra::readToAnyBurst(sin);
+  if (type != 14)
+    throw JavaError("alignment", "Expecting flags start");
+  sin >> dec >> flags;
+  type = ArchitectureGhidra::readToAnyBurst(sin);
+  if (type != 15)
+    throw JavaError("alignment", "Expecting flags end");
+
+  // Read address count
+  type = ArchitectureGhidra::readToAnyBurst(sin);
+  if (type != 14)
+    throw JavaError("alignment", "Expecting address count start");
+  int4 count;
+  sin >> dec >> count;
+  type = ArchitectureGhidra::readToAnyBurst(sin);
+  if (type != 15)
+    throw JavaError("alignment", "Expecting address count end");
+
+  // Read addresses
+  addresses.resize(count);
+  for (int4 i = 0; i < count; ++i) {
+    type = ArchitectureGhidra::readToAnyBurst(sin);
+    if (type != 14)
+      throw JavaError("alignment", "Expecting address start");
+    sin >> hex >> addresses[i];
+    type = ArchitectureGhidra::readToAnyBurst(sin);
+    if (type != 15)
+      throw JavaError("alignment", "Expecting address end");
+  }
+}
+
+void SetDecompilerFixes::rawAction(void)
+
+{
+  for (size_t i = 0; i < addresses.size(); ++i) {
+    DecompilerFixes::addFixes(addresses[i], flags);
+  }
+  res = true;
+}
+
+void SetDecompilerFixes::sendResult(void)
+
+{
+  sout.write("\000\000\001\016", 4);
+  if (res)
+    sout << 't';
+  else
+    sout << 'f';
+  sout.write("\000\000\001\017", 4);
+  sout.write("\000\000\001\007", 4);  // End of command response
+  sout.flush();
+}
+
+/// Load parameters for ClearDecompilerFixes - reads and ignores arch id
+void ClearDecompilerFixes::loadParameters(void)
+
+{
+  // Read and ignore arch id (for protocol compatibility)
+  int4 type = ArchitectureGhidra::readToAnyBurst(sin);
+  if (type != 14)
+    throw JavaError("alignment", "Expecting arch id start");
+  int4 ignoredId;
+  sin >> dec >> ignoredId;
+  type = ArchitectureGhidra::readToAnyBurst(sin);
+  if (type != 15)
+    throw JavaError("alignment", "Expecting arch id end");
+}
+
+void ClearDecompilerFixes::rawAction(void)
+
+{
+  DecompilerFixes::clearAll();
+  res = true;
+}
+
+void ClearDecompilerFixes::sendResult(void)
+
+{
+  sout.write("\000\000\001\016", 4);
+  if (res)
+    sout << 't';
+  else
+    sout << 'f';
+  sout.write("\000\000\001\017", 4);
+  sout.write("\000\000\001\007", 4);  // End of command response
+  sout.flush();
+}
+
+}
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
index 9ec6788370..0501089936 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
@@ -503,6 +503,8 @@ void GhidraDecompCapability::initialize(void)
   commandmap["structureGraph"] = new StructureGraph();
   commandmap["setAction"] = new SetAction();
   commandmap["setOptions"] = new SetOptions();
+  commandmap["setDecompilerFixes"] = new SetDecompilerFixes();
+  commandmap["clearDecompilerFixes"] = new ClearDecompilerFixes();
 }
 
 } // End namespace ghidra
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
index db72be59bd..ad3213e081 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
@@ -237,6 +237,36 @@ public:
   virtual void rawAction(void);
 };
 
+/// \brief Command to \b register per-function decompiler fixes
+///
+/// This command registers a set of function addresses to receive specific decompiler fixes.
+/// The fixes are identified by flag values (see DecompilerFixFlags).
+/// The command does not require an Architecture - it operates on a global registry.
+/// It expects 2 parameters: a flags value and a list of addresses.
+class SetDecompilerFixes : public GhidraCommand {
+  uint4 flags;				///< The fix flags to apply
+  vector<uint8> addresses;		///< The function addresses to register
+  virtual void loadParameters(void);
+  virtual void sendResult(void);
+public:
+  bool res;				///< Set to \b true if the registration succeeded
+  SetDecompilerFixes(void) : flags(0), res(false) {}	///< Constructor
+  virtual void rawAction(void);
+};
+
+/// \brief Command to \b clear all registered decompiler fixes
+///
+/// This command clears all function addresses from the decompiler fixes registry.
+/// The command does not require an Architecture - it operates on a global registry.
+class ClearDecompilerFixes : public GhidraCommand {
+  virtual void loadParameters(void);
+  virtual void sendResult(void);
+public:
+  bool res;				///< Set to \b true if the clear succeeded
+  ClearDecompilerFixes(void) : res(false) {}	///< Constructor
+  virtual void rawAction(void);
+};
+
 #ifdef __REMOTE_SOCKET__
 extern void connect_to_console(Funcdata *fd);
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
index 0f73153c06..ec705cc4fa 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
@@ -16,6 +16,7 @@
 #include "heritage.hh"
 #include "funcdata.hh"
 #include "prefersplit.hh"
+#include "multiequal_trace.hh"
 
 namespace ghidra {
 
@@ -1053,7 +1054,21 @@ bool Heritage::discoverIndexedStackPointers(AddrSpace *spc,vector<PcodeOp *> &fr
 	}
 	case CPUI_MULTIEQUAL:
 	{
-	  StackNode nextNode(outVn,curNode.offset,curNode.traversals | StackNode::multiequal);
+	  // Check if all MULTIEQUAL inputs trace back to ESP with the same offset.
+	  // If so, the output has a definite offset and we don't need to mark as uncertain
+	  uintb commonOffset;
+	  uint4 newTraversals = curNode.traversals;
+	  uintb newOffset = curNode.offset;
+
+	  if (checkMultiequalStackOffsets(op, spc, spInput, fd->getAddress().getOffset(), commonOffset)) {
+	    // All inputs have same offset - use the verified offset, don't set multiequal flag
+	    newOffset = commonOffset;
+	  } else {
+	    // Inputs differ or can't be traced - mark as uncertain
+	    newTraversals |= StackNode::multiequal;
+	  }
+
+	  StackNode nextNode(outVn, newOffset, newTraversals);
 	  if (nextNode.iter != nextNode.vn->endDescend()) {
 	    outVn->setMark();
 	    path.push_back(nextNode);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/multiequal_trace.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/multiequal_trace.cc
new file mode 100644
index 0000000000..1b013e6986
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/multiequal_trace.cc
@@ -0,0 +1,210 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/// \file multiequal_trace.cc
+/// \brief MULTIEQUAL stack offset tracing implementation
+
+#include "multiequal_trace.hh"
+#include "decompiler_fixes.hh"
+#include "decomp_dbg.hh"
+#include <set>
+
+namespace ghidra {
+
+/// \brief Trace a varnode backward to determine its offset from the stack pointer
+///
+/// This function walks backward through the definition chain of a varnode to determine
+/// if it derives from the stack pointer (ESP) and what constant offset it has.
+/// Used to verify that all inputs to a MULTIEQUAL have the same ESP offset.
+///
+/// \param vn is the varnode to trace backward
+/// \param spc is the stack address space
+/// \param spInput is the stack pointer input varnode to match against
+/// \param offset will receive the calculated offset from ESP
+/// \param visited is a set of visited varnodes for cycle detection
+/// \param depth is the current recursion depth
+/// \return true if the varnode traces back to ESP with a constant offset
+static bool traceStackOffsetBackward(Varnode *vn, AddrSpace *spc, Varnode *spInput,
+                                      uintb &offset, set<Varnode *> &visited, int4 depth)
+{
+  if (depth > 16) {
+    DECOMP_LOG("  traceBack[" << depth << "]: max depth exceeded");
+    return false;
+  }
+
+  if (visited.find(vn) != visited.end()) {
+    DECOMP_LOG("  traceBack[" << depth << "]: cycle detected");
+    return false;
+  }
+  visited.insert(vn);
+
+  // Check if this is the stack pointer input
+  if (vn == spInput) {
+    offset = 0;
+    DECOMP_LOG("  traceBack[" << depth << "]: FOUND ESP input! offset=0");
+    return true;
+  }
+
+  // Check if this varnode is in the stack space itself
+  // Stack space varnodes ARE ESP-relative by definition - their offset IS the ESP offset
+  if (vn->getSpace() == spc) {
+    offset = vn->getOffset();
+    DECOMP_LOG("  traceBack[" << depth << "]: FOUND stack space varnode! offset=0x" << std::hex << offset);
+    return true;
+  }
+
+  // Check if this is an input varnode (but not ESP)
+  if (vn->isInput()) {
+    DECOMP_LOG("  traceBack[" << depth << "]: hit non-ESP input " << vn->getSpace()->getName()
+                  << ":0x" << std::hex << vn->getOffset());
+    return false;
+  }
+
+  // Must be written
+  if (!vn->isWritten()) {
+    DECOMP_LOG("  traceBack[" << depth << "]: not written, not input");
+    return false;
+  }
+
+  PcodeOp *defop = vn->getDef();
+  OpCode opc = defop->code();
+
+  switch (opc) {
+    case CPUI_COPY:
+    case CPUI_INDIRECT:
+    case CPUI_INT_AND:  // Stack alignment
+    {
+      // Offset unchanged, trace through input
+      return traceStackOffsetBackward(defop->getIn(0), spc, spInput, offset, visited, depth + 1);
+    }
+    case CPUI_INT_ADD:
+    {
+      Varnode *in0 = defop->getIn(0);
+      Varnode *in1 = defop->getIn(1);
+
+      // One input should be constant
+      if (in1->isConstant()) {
+        uintb baseOffset;
+        if (traceStackOffsetBackward(in0, spc, spInput, baseOffset, visited, depth + 1)) {
+          offset = spc->wrapOffset(baseOffset + in1->getOffset());
+          return true;
+        }
+      }
+      else if (in0->isConstant()) {
+        uintb baseOffset;
+        if (traceStackOffsetBackward(in1, spc, spInput, baseOffset, visited, depth + 1)) {
+          offset = spc->wrapOffset(baseOffset + in0->getOffset());
+          return true;
+        }
+      }
+      DECOMP_LOG("  traceBack[" << depth << "]: INT_ADD with no constant");
+      return false;
+    }
+    case CPUI_INT_SUB:
+    {
+      Varnode *in0 = defop->getIn(0);
+      Varnode *in1 = defop->getIn(1);
+
+      // Second input should be constant (ESP - constant)
+      if (in1->isConstant()) {
+        uintb baseOffset;
+        if (traceStackOffsetBackward(in0, spc, spInput, baseOffset, visited, depth + 1)) {
+          offset = spc->wrapOffset(baseOffset - in1->getOffset());
+          return true;
+        }
+      }
+      DECOMP_LOG("  traceBack[" << depth << "]: INT_SUB with no constant");
+      return false;
+    }
+    case CPUI_MULTIEQUAL:
+    {
+      // For nested MULTIEQUAL, check if all inputs have same offset
+      uintb firstOffset = 0;
+      bool firstSet = false;
+
+      for (int4 i = 0; i < defop->numInput(); ++i) {
+        set<Varnode *> branchVisited = visited;  // Fresh visited set per branch
+        uintb branchOffset;
+
+        if (!traceStackOffsetBackward(defop->getIn(i), spc, spInput, branchOffset, branchVisited, depth + 1)) {
+          DECOMP_LOG("  traceBack[" << depth << "]: MULTIEQUAL input " << i << " failed");
+          return false;
+        }
+
+        if (!firstSet) {
+          firstOffset = branchOffset;
+          firstSet = true;
+        }
+        else if (branchOffset != firstOffset) {
+          DECOMP_LOG("  traceBack[" << depth << "]: MULTIEQUAL inputs have different offsets: 0x"
+                        << std::hex << firstOffset << " vs 0x" << branchOffset);
+          return false;
+        }
+      }
+
+      offset = firstOffset;
+      DECOMP_LOG("  traceBack[" << depth << "]: MULTIEQUAL all inputs same offset=0x" << std::hex << offset);
+      return true;
+    }
+    default:
+      DECOMP_LOG("  traceBack[" << depth << "]: unsupported opcode " << (int)opc);
+      return false;
+  }
+}
+
+bool checkMultiequalStackOffsets(PcodeOp *op, AddrSpace *spc, Varnode *spInput, uint8 funcAddr, uintb &commonOffset)
+{
+  // Check if the fix is enabled for this function
+  if (!DecompilerFixes::hasFix(funcAddr, DFIX_MULTIEQUAL_STACK_TRACE)) {
+    return false;  // Fix not enabled, use default behavior
+  }
+
+  DECOMP_LOG("checkMultiequalStackOffsets: checking MULTIEQUAL with " << op->numInput() << " inputs");
+
+  uintb firstOffset = 0;
+  bool firstSet = false;
+
+  for (int4 i = 0; i < op->numInput(); ++i) {
+    Varnode *inputVn = op->getIn(i);
+    set<Varnode *> visited;
+    uintb inputOffset;
+
+    DECOMP_LOG("  checking input " << i << ": " << inputVn->getSpace()->getName()
+                  << ":0x" << std::hex << inputVn->getOffset());
+
+    if (!traceStackOffsetBackward(inputVn, spc, spInput, inputOffset, visited, 0)) {
+      DECOMP_LOG("  input " << i << " FAILED to trace to ESP");
+      return false;
+    }
+
+    DECOMP_LOG("  input " << i << " traced to ESP offset=0x" << std::hex << inputOffset);
+
+    if (!firstSet) {
+      firstOffset = inputOffset;
+      firstSet = true;
+    }
+    else if (inputOffset != firstOffset) {
+      DECOMP_LOG("  MULTIEQUAL inputs have DIFFERENT offsets: 0x" << std::hex << firstOffset
+                    << " vs 0x" << inputOffset);
+      return false;
+    }
+  }
+
+  commonOffset = firstOffset;
+  DECOMP_LOG("checkMultiequalStackOffsets: SUCCESS! All inputs have offset=0x" << std::hex << commonOffset);
+  return true;
+}
+
+}
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/multiequal_trace.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/multiequal_trace.hh
new file mode 100644
index 0000000000..843e4ca0f4
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/multiequal_trace.hh
@@ -0,0 +1,47 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/// \file multiequal_trace.hh
+/// \brief MULTIEQUAL stack offset tracing for heritage analysis
+
+#ifndef __MULTIEQUAL_TRACE_HH__
+#define __MULTIEQUAL_TRACE_HH__
+
+#include "op.hh"
+#include "space.hh"
+#include "varnode.hh"
+
+namespace ghidra {
+
+/// \brief Check if all MULTIEQUAL inputs have the same stack offset
+///
+/// Given a MULTIEQUAL operation, trace backward through all its inputs to determine
+/// if they all derive from ESP with the same constant offset. If so, the MULTIEQUAL
+/// output has a definite stack offset and doesn't need to be marked as uncertain.
+///
+/// This function first checks if the DFIX_MULTIEQUAL_STACK_TRACE fix is enabled
+/// for the given function address via the DecompilerFixes registry.
+///
+/// \param op is the MULTIEQUAL operation
+/// \param spc is the stack address space
+/// \param spInput is the stack pointer input varnode
+/// \param funcAddr is the function entry address (for fix registry lookup)
+/// \param commonOffset will receive the common offset if all inputs match
+/// \return true if all inputs have the same definite offset from ESP
+extern bool checkMultiequalStackOffsets(PcodeOp *op, AddrSpace *spc, Varnode *spInput, uint8 funcAddr, uintb &commonOffset);
+
+}
+
+#endif
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompInterface.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompInterface.java
index 25622a2c93..f63d4b5f7a 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompInterface.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompInterface.java
@@ -82,6 +82,14 @@ import ghidra.util.task.TaskMonitor;
  */
 public class DecompInterface {
 
+	/**
+	 * Decompiler fix flags - used with setDecompilerFixes() to enable per-function fixes.
+	 * These must match DecompilerFixFlags in decompiler_fixes.hh
+	 */
+	public static final int DFIX_NONE = 0;
+	/** Trace MULTIEQUAL inputs for precise stack offsets in heritage analysis */
+	public static final int DFIX_MULTIEQUAL_STACK_TRACE = 1 << 0;
+
 	public static class EncodeDecodeSet {
 		public OverlayAddressSpace overlay;		// Active overlay space or null
 		public CachedEncoder mainQuery;		// Encoder for main query to decompiler process
@@ -1121,4 +1129,45 @@ public class DecompInterface {
 		}
 		return null;
 	}
+
+	/**
+	 * Register per-function decompiler fixes for a set of function addresses.
+	 * The fixes will be applied during subsequent decompilation of these functions.
+	 * @param flags the fix flags to apply (use DFIX_* constants)
+	 * @param addresses array of function entry addresses
+	 * @return true if the command succeeded
+	 */
+	public synchronized boolean setDecompilerFixes(int flags, long[] addresses) {
+		if (decompProcess == null) {
+			return false;
+		}
+		try {
+			StringIngest response = new StringIngest();
+			decompProcess.sendSetDecompilerFixes(flags, addresses, response);
+			return response.toString().equals("t");
+		}
+		catch (Exception e) {
+			Msg.error(this, "Exception setting decompiler fixes: " + e.getMessage());
+			return false;
+		}
+	}
+
+	/**
+	 * Clear all registered per-function decompiler fixes.
+	 * @return true if the command succeeded
+	 */
+	public synchronized boolean clearDecompilerFixes() {
+		if (decompProcess == null) {
+			return false;
+		}
+		try {
+			StringIngest response = new StringIngest();
+			decompProcess.sendClearDecompilerFixes(response);
+			return response.toString().equals("t");
+		}
+		catch (Exception e) {
+			Msg.error(this, "Exception clearing decompiler fixes: " + e.getMessage());
+			return false;
+		}
+	}
 }
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java
index d43fa7e46e..4d5b123167 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java
@@ -21,8 +21,10 @@ import static ghidra.program.model.pcode.ElementId.*;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.nio.charset.StandardCharsets;
+import java.util.*;
 
 import ghidra.app.cmd.function.CallDepthChangeInfo;
+import ghidra.app.plugin.processors.sleigh.SleighLanguage;
 import ghidra.docking.settings.SettingsImpl;
 import ghidra.program.disassemble.Disassembler;
 import ghidra.program.model.address.*;
@@ -33,6 +35,7 @@ import ghidra.program.model.listing.*;
 import ghidra.program.model.mem.MemoryAccessException;
 import ghidra.program.model.mem.MemoryBufferImpl;
 import ghidra.program.model.pcode.*;
+import ghidra.program.model.pcode.PcodeOverride;
 import ghidra.program.model.symbol.*;
 import ghidra.util.Msg;
 import ghidra.util.UndefinedFunction;
@@ -50,6 +53,476 @@ public class DecompileCallback {
 
 	public final static int MAX_SYMBOL_COUNT = 16;
 
+	// P-code override support - registered overrides keyed by funcAddr -> instrAddr -> pcodeLines
+	private static Map<Long, Map<Long, List<String>>> pcodeOverrides = new HashMap<>();
+
+	/**
+	 * Register a P-code override for a specific instruction within a function.
+	 * @param funcAddr the function entry address
+	 * @param instrAddr the instruction address to override
+	 * @param pcodeLines the P-code operation strings to use instead
+	 */
+	public static void registerPcodeOverride(long funcAddr, long instrAddr, List<String> pcodeLines) {
+		pcodeOverrides.computeIfAbsent(funcAddr, k -> new HashMap<>()).put(instrAddr, pcodeLines);
+	}
+
+	/**
+	 * Clear all registered P-code overrides.
+	 */
+	public static void clearPcodeOverrides() {
+		pcodeOverrides.clear();
+	}
+
+	/**
+	 * Check if any P-code overrides are registered.
+	 * @return true if overrides exist
+	 */
+	public static boolean hasPcodeOverrides() {
+		return !pcodeOverrides.isEmpty();
+	}
+
+	// Callfixup support - register callfixups with Ghidra's native PcodeInjectLibrary
+	// Uses SLEIGH syntax in the body, matching cspec format
+
+	/**
+	 * Definition of a callfixup to be registered with PcodeInjectLibrary.
+	 */
+	private static class CallFixupDefinition {
+		final String name;
+		final List<String> targets;
+		final List<String> body;  // SLEIGH statements
+		final int paramshift;
+
+		CallFixupDefinition(String name, List<String> targets, List<String> body, int paramshift) {
+			this.name = name;
+			this.targets = targets;
+			this.body = body;
+			this.paramshift = paramshift;
+		}
+	}
+
+	// Pending callfixups to be installed when DecompileCallback is instantiated
+	private static List<CallFixupDefinition> pendingCallFixups = new ArrayList<>();
+	// Track which callfixups were installed (for cleanup)
+	private static Set<String> installedCallFixupNames = new HashSet<>();
+	// Map target function names to callfixup names (for lookup override)
+	private static Map<String, String> targetToCallFixupName = new HashMap<>();
+
+	/**
+	 * Register a callfixup for multiple exact target names.
+	 * The callfixup will be installed to Ghidra's native PcodeInjectLibrary when
+	 * decompilation starts, using SLEIGH syntax for the body.
+	 * @param name the callfixup name (used in warnings/logging)
+	 * @param targetNames list of exact function names to match
+	 * @param sleighBody list of SLEIGH statements (e.g., "ESP = ESP - EAX;")
+	 * @param paramshift number of parameters to shift (remove from front of param list)
+	 */
+	public static void registerCallFixupTargets(String name, List<String> targetNames, List<String> sleighBody, int paramshift) {
+		if (targetNames == null || targetNames.isEmpty()) {
+			return;
+		}
+		if (name == null || name.isEmpty()) {
+			// Fallback: generate name from first target
+			name = "annot_" + targetNames.get(0).replaceAll("[^a-zA-Z0-9_]", "_");
+		}
+		pendingCallFixups.add(new CallFixupDefinition(name, new ArrayList<>(targetNames),
+			new ArrayList<>(sleighBody), paramshift));
+	}
+
+	/**
+	 * Clear all registered callfixups.
+	 * Note: Callfixups already installed to PcodeInjectLibrary cannot be removed
+	 * without program restart.
+	 */
+	public static void clearCallFixups() {
+		pendingCallFixups.clear();
+		// Note: installedCallFixupNames is not cleared - those are in the library
+	}
+
+	/**
+	 * Check if any callfixups are registered or pending.
+	 * @return true if callfixups exist
+	 */
+	public static boolean hasCallFixups() {
+		return !pendingCallFixups.isEmpty() || !installedCallFixupNames.isEmpty();
+	}
+
+	/**
+	 * Install pending callfixups to the given PcodeInjectLibrary.
+	 * Builds XML matching cspec format and uses restoreXmlInject.
+	 * @param library the PcodeInjectLibrary to register with
+	 * @param language the SleighLanguage for parsing
+	 */
+	private static void installPendingCallFixups(PcodeInjectLibrary library, SleighLanguage language) {
+		if (pendingCallFixups.isEmpty()) {
+			return;
+		}
+
+		for (CallFixupDefinition def : pendingCallFixups) {
+			// Skip if already installed
+			if (installedCallFixupNames.contains(def.name)) {
+				continue;
+			}
+
+			// Check if a callfixup with this name already exists in the library
+			if (library.getPayload(InjectPayload.CALLFIXUP_TYPE, def.name) != null) {
+				continue;
+			}
+
+			try {
+				// Build XML string matching cspec format
+				StringBuilder xml = new StringBuilder();
+				xml.append("<callfixup name=\"").append(escapeXml(def.name)).append("\">\n");
+				for (String target : def.targets) {
+					xml.append("  <target name=\"").append(escapeXml(target)).append("\"/>\n");
+				}
+				xml.append("  <pcode");
+				if (def.paramshift > 0) {
+					xml.append(" paramshift=\"").append(def.paramshift).append("\"");
+				}
+				xml.append(">\n");
+				xml.append("    <body><![CDATA[\n");
+				for (String stmt : def.body) {
+					xml.append("      ").append(stmt).append("\n");
+				}
+				xml.append("    ]]></body>\n");
+				xml.append("  </pcode>\n");
+				xml.append("</callfixup>\n");
+
+				String xmlStr = xml.toString();
+
+				// Parse XML and register
+				ghidra.xml.XmlPullParser parser = new ghidra.xml.NonThreadedXmlPullParserImpl(
+					xmlStr, "callfixup:" + def.name, null, false);
+				library.restoreXmlInject("annotation", def.name, InjectPayload.CALLFIXUP_TYPE, parser);
+
+				installedCallFixupNames.add(def.name);
+				// Map each target to this callfixup name for lookup override
+				for (String target : def.targets) {
+					targetToCallFixupName.put(target, def.name);
+				}
+			}
+			catch (Exception e) {
+				Msg.error(DecompileCallback.class, "Failed to install callfixup '" + def.name + "': " + e.getMessage());
+			}
+		}
+
+		// Clear pending list after installation
+		pendingCallFixups.clear();
+	}
+
+	/**
+	 * Escape special XML characters in a string.
+	 */
+	private static String escapeXml(String s) {
+		return s.replace("&", "&amp;")
+				.replace("<", "&lt;")
+				.replace(">", "&gt;")
+				.replace("\"", "&quot;")
+				.replace("'", "&apos;");
+	}
+
+	/**
+	 * Get the callfixup name for a target function, if one is registered.
+	 * @param funcName the target function name
+	 * @return the callfixup name, or null if no mapping exists
+	 */
+	public static String getCallFixupForTarget(String funcName) {
+		return targetToCallFixupName.get(funcName);
+	}
+
+	/**
+	 * Apply an annotation-based callfixup to a function if one is registered.
+	 * This sets the inject name on the function prototype so it will be sent to the decompiler.
+	 * @param func the function to check
+	 * @param hfunc the HighFunction whose prototype to update
+	 */
+	private static void applyAnnotationCallfixup(Function func, HighFunction hfunc) {
+		// Only apply if no callfixup already set (don't override database callfixups)
+		if (func.getCallFixup() != null) {
+			return;
+		}
+		String fixupName = getCallFixupForTarget(func.getName());
+		if (fixupName != null) {
+			hfunc.getFunctionPrototype().setInjectName(fixupName);
+		}
+	}
+
+	/**
+	 * Custom PcodeOverride wrapper that checks our target-to-callfixup mapping
+	 * before falling back to the database-stored callfixup.
+	 */
+	private static class AnnotationPcodeOverride extends InstructionPcodeOverride {
+		private final CompilerSpec compilerSpec;
+
+		public AnnotationPcodeOverride(Instruction instr, CompilerSpec compilerSpec) {
+			super(instr);
+			this.compilerSpec = compilerSpec;
+		}
+
+		@Override
+		public boolean hasCallFixup(Address callDestAddr) {
+			// First check our annotation-based mapping
+			Program program = instr.getProgram();
+			Function func = program.getFunctionManager().getFunctionAt(callDestAddr);
+			if (func != null) {
+				String fixupName = getCallFixupForTarget(func.getName());
+				if (fixupName != null) {
+					return true;
+				}
+			}
+			// Fall back to database-stored callfixup
+			return super.hasCallFixup(callDestAddr);
+		}
+
+		@Override
+		public InjectPayload getCallFixup(Address callDestAddr) {
+			// First check our annotation-based mapping
+			Program program = instr.getProgram();
+			Function func = program.getFunctionManager().getFunctionAt(callDestAddr);
+			if (func != null) {
+				String fixupName = getCallFixupForTarget(func.getName());
+				if (fixupName != null) {
+					InjectPayload payload = compilerSpec.getPcodeInjectLibrary()
+						.getPayload(InjectPayload.CALLFIXUP_TYPE, fixupName);
+					if (payload != null) {
+						return payload;
+					}
+				}
+			}
+			// Fall back to database-stored callfixup
+			return super.getCallFixup(callDestAddr);
+		}
+	}
+
+	/**
+	 * Parse a pcode operation string into a PcodeOp.
+	 * Format: OPCODE (output) = (input1), (input2), ...
+	 * Varnode format: (space,offset,size) or (space,0xoffset,size)
+	 * @param opStr the pcode operation string
+	 * @param addr the instruction address
+	 * @param seqNum the sequence number within the instruction
+	 * @param addrFactory the address factory for space lookups
+	 * @return the parsed PcodeOp, or null on error
+	 */
+	private static PcodeOp parsePcodeOp(String opStr, Address addr, int seqNum, AddressFactory addrFactory) {
+		try {
+
+			// Remove inline comments
+			int commentIdx = opStr.indexOf("/*");
+			if (commentIdx >= 0) {
+				int endComment = opStr.indexOf("*/", commentIdx);
+				if (endComment >= 0) {
+					opStr = opStr.substring(0, commentIdx) + opStr.substring(endComment + 2);
+				}
+			}
+			opStr = opStr.trim();
+
+			// Parse opcode name
+			int firstParen = opStr.indexOf('(');
+			if (firstParen < 0) {
+				return null;
+			}
+			String prefix = opStr.substring(0, firstParen).trim();
+
+			// Check for output assignment: OPCODE (output) = (inputs...)
+			int equalsIdx = opStr.indexOf('=');
+			int opcode;
+			Varnode output = null;
+			String inputsPart;
+
+			// Has output
+			if (equalsIdx > 0 && equalsIdx > firstParen) {
+				String opcodeName = prefix;
+				opcode = getOpcodeFromName(opcodeName);
+				if (opcode < 0) return null;
+
+				String outputPart = opStr.substring(firstParen, equalsIdx).trim();
+				output = parseVarnode(outputPart, addrFactory);
+
+				inputsPart = opStr.substring(equalsIdx + 1).trim();
+			}
+			else {
+				// No output (e.g., STORE, BRANCH)
+				opcode = getOpcodeFromName(prefix);
+				if (opcode < 0) return null;
+				inputsPart = opStr.substring(firstParen).trim();
+			}
+
+			// Parse inputs
+			List<Varnode> inputs = new ArrayList<>();
+			int depth = 0;
+			int start = -1;
+			for (int i = 0; i < inputsPart.length(); i++) {
+				char c = inputsPart.charAt(i);
+				if (c == '(') {
+					if (depth == 0) start = i;
+					depth++;
+				} else if (c == ')') {
+					depth--;
+					if (depth == 0 && start >= 0) {
+						String varnodeStr = inputsPart.substring(start, i + 1);
+						Varnode v = parseVarnode(varnodeStr, addrFactory);
+						if (v != null) {
+							inputs.add(v);
+						}
+						start = -1;
+					}
+				}
+			}
+
+			// Create the PcodeOp
+			SequenceNumber seq = new SequenceNumber(addr, seqNum);
+			PcodeOp op = new PcodeOp(seq, opcode, inputs.toArray(new Varnode[0]), output);
+			return op;
+		} catch (Exception e) {
+			Msg.warn(DecompileCallback.class, "P-code override: Error parsing pcode op: " + opStr + " - " + e.getMessage());
+			return null;
+		}
+	}
+
+	/**
+	 * Parse a varnode string like (register,0x10,4) or (const,0x1a1,4)
+	 */
+	private static Varnode parseVarnode(String str, AddressFactory addrFactory) {
+
+		// Parse varnode string
+		str = str.trim();
+		if (!str.startsWith("(") || !str.endsWith(")")) {
+			return null;
+		}
+		str = str.substring(1, str.length() - 1);
+		String[] parts = str.split(",");
+		if (parts.length != 3) {
+			return null;
+		}
+		String spaceName = parts[0].trim();
+		String offsetStr = parts[1].trim();
+		String sizeStr = parts[2].trim();
+		try {
+
+			// Get offset and size
+			long offset;
+			if (offsetStr.startsWith("0x") || offsetStr.startsWith("0X")) {
+				offset = Long.parseUnsignedLong(offsetStr.substring(2), 16);
+			} else {
+				offset = Long.parseUnsignedLong(offsetStr);
+			}
+			int size = Integer.parseInt(sizeStr);
+
+			// Find address space
+			AddressSpace space = addrFactory.getAddressSpace(spaceName);
+			if (space == null) {
+
+				// Try common aliases
+				if ("const".equals(spaceName)) {
+					space = addrFactory.getConstantSpace();
+				} else if ("unique".equals(spaceName)) {
+					space = addrFactory.getUniqueSpace();
+				} else if ("register".equals(spaceName)) {
+					space = addrFactory.getRegisterSpace();
+				} else if ("ram".equals(spaceName)) {
+					space = addrFactory.getDefaultAddressSpace();
+				} else if ("stack".equals(spaceName)) {
+					space = addrFactory.getStackSpace();
+				}
+			}
+			if (space == null) {
+				Msg.warn(DecompileCallback.class, "P-code override: Unknown address space: " + spaceName);
+				return null;
+			}
+
+			// Return varnode
+			Address address = space.getAddress(offset);
+			return new Varnode(address, size);
+		} catch (NumberFormatException e) {
+			Msg.warn(DecompileCallback.class, "P-code override: Error parsing varnode numbers: " + str);
+			return null;
+		}
+	}
+
+	/**
+	 * Convert pcode opcode name to integer constant.
+	 */
+	private static int getOpcodeFromName(String name) {
+		switch (name.toUpperCase()) {
+			case "COPY": return PcodeOp.COPY;
+			case "LOAD": return PcodeOp.LOAD;
+			case "STORE": return PcodeOp.STORE;
+			case "BRANCH": return PcodeOp.BRANCH;
+			case "CBRANCH": return PcodeOp.CBRANCH;
+			case "BRANCHIND": return PcodeOp.BRANCHIND;
+			case "CALL": return PcodeOp.CALL;
+			case "CALLIND": return PcodeOp.CALLIND;
+			case "CALLOTHER": return PcodeOp.CALLOTHER;
+			case "RETURN": return PcodeOp.RETURN;
+			case "INT_EQUAL": return PcodeOp.INT_EQUAL;
+			case "INT_NOTEQUAL": return PcodeOp.INT_NOTEQUAL;
+			case "INT_SLESS": return PcodeOp.INT_SLESS;
+			case "INT_SLESSEQUAL": return PcodeOp.INT_SLESSEQUAL;
+			case "INT_LESS": return PcodeOp.INT_LESS;
+			case "INT_LESSEQUAL": return PcodeOp.INT_LESSEQUAL;
+			case "INT_ZEXT": return PcodeOp.INT_ZEXT;
+			case "INT_SEXT": return PcodeOp.INT_SEXT;
+			case "INT_ADD": return PcodeOp.INT_ADD;
+			case "INT_SUB": return PcodeOp.INT_SUB;
+			case "INT_CARRY": return PcodeOp.INT_CARRY;
+			case "INT_SCARRY": return PcodeOp.INT_SCARRY;
+			case "INT_SBORROW": return PcodeOp.INT_SBORROW;
+			case "INT_2COMP": return PcodeOp.INT_2COMP;
+			case "INT_NEGATE": return PcodeOp.INT_NEGATE;
+			case "INT_XOR": return PcodeOp.INT_XOR;
+			case "INT_AND": return PcodeOp.INT_AND;
+			case "INT_OR": return PcodeOp.INT_OR;
+			case "INT_LEFT": return PcodeOp.INT_LEFT;
+			case "INT_RIGHT": return PcodeOp.INT_RIGHT;
+			case "INT_SRIGHT": return PcodeOp.INT_SRIGHT;
+			case "INT_MULT": return PcodeOp.INT_MULT;
+			case "INT_DIV": return PcodeOp.INT_DIV;
+			case "INT_SDIV": return PcodeOp.INT_SDIV;
+			case "INT_REM": return PcodeOp.INT_REM;
+			case "INT_SREM": return PcodeOp.INT_SREM;
+			case "BOOL_NEGATE": return PcodeOp.BOOL_NEGATE;
+			case "BOOL_XOR": return PcodeOp.BOOL_XOR;
+			case "BOOL_AND": return PcodeOp.BOOL_AND;
+			case "BOOL_OR": return PcodeOp.BOOL_OR;
+			case "FLOAT_EQUAL": return PcodeOp.FLOAT_EQUAL;
+			case "FLOAT_NOTEQUAL": return PcodeOp.FLOAT_NOTEQUAL;
+			case "FLOAT_LESS": return PcodeOp.FLOAT_LESS;
+			case "FLOAT_LESSEQUAL": return PcodeOp.FLOAT_LESSEQUAL;
+			case "FLOAT_NAN": return PcodeOp.FLOAT_NAN;
+			case "FLOAT_ADD": return PcodeOp.FLOAT_ADD;
+			case "FLOAT_DIV": return PcodeOp.FLOAT_DIV;
+			case "FLOAT_MULT": return PcodeOp.FLOAT_MULT;
+			case "FLOAT_SUB": return PcodeOp.FLOAT_SUB;
+			case "FLOAT_NEG": return PcodeOp.FLOAT_NEG;
+			case "FLOAT_ABS": return PcodeOp.FLOAT_ABS;
+			case "FLOAT_SQRT": return PcodeOp.FLOAT_SQRT;
+			case "FLOAT_INT2FLOAT": return PcodeOp.FLOAT_INT2FLOAT;
+			case "FLOAT_FLOAT2FLOAT": return PcodeOp.FLOAT_FLOAT2FLOAT;
+			case "FLOAT_TRUNC": return PcodeOp.FLOAT_TRUNC;
+			case "FLOAT_CEIL": return PcodeOp.FLOAT_CEIL;
+			case "FLOAT_FLOOR": return PcodeOp.FLOAT_FLOOR;
+			case "FLOAT_ROUND": return PcodeOp.FLOAT_ROUND;
+			case "FLOAT2FLOAT": return PcodeOp.FLOAT_FLOAT2FLOAT;
+			case "INT2FLOAT": return PcodeOp.FLOAT_INT2FLOAT;
+			case "TRUNC": return PcodeOp.FLOAT_TRUNC;
+			case "MULTIEQUAL": return PcodeOp.MULTIEQUAL;
+			case "INDIRECT": return PcodeOp.INDIRECT;
+			case "PIECE": return PcodeOp.PIECE;
+			case "SUBPIECE": return PcodeOp.SUBPIECE;
+			case "CAST": return PcodeOp.CAST;
+			case "PTRADD": return PcodeOp.PTRADD;
+			case "PTRSUB": return PcodeOp.PTRSUB;
+			case "POPCOUNT": return PcodeOp.POPCOUNT;
+			case "LZCOUNT": return PcodeOp.LZCOUNT;
+			case "UNIMPLEMENTED": return PcodeOp.UNIMPLEMENTED;
+			default:
+				Msg.warn(DecompileCallback.class, "P-code override: Unknown pcode opcode: " + name);
+				return -1;
+		}
+	}
+
 	/**
 	 * Data returned for a query about strings
 	 */
@@ -96,6 +569,12 @@ public class DecompileCallback {
 		cpool = null;
 		nativeMessage = null;
 		debug = null;
+
+		// Install any pending callfixups to the native PcodeInjectLibrary
+		if (!pendingCallFixups.isEmpty() && language instanceof SleighLanguage) {
+			PcodeInjectLibrary library = compilerSpec.getPcodeInjectLibrary();
+			installPendingCallFixups(library, (SleighLanguage) language);
+		}
 	}
 
 	/**
@@ -227,9 +706,54 @@ public class DecompileCallback {
 				}
 			}
 
+			// Check for P-code override
+			if (!pcodeOverrides.isEmpty() && funcEntry != null) {
+				PcodeOp[] patchedOps = getPatchedPcode(addr, instr);
+				if (patchedOps != null) {
+					int fallthruOffset = instr.getDefaultFallThroughOffset();
+					try {
+						// First, capture what the original encoding would produce for comparison
+						PatchPackedEncode origEncoder = new PatchPackedEncode();
+						origEncoder.clear();
+						instr.getPrototype().getPcodePacked(origEncoder, instr.getInstructionContext(),
+							new AnnotationPcodeOverride(instr, pcodecompilerspec));
+						int origSize = origEncoder.size();
+
+						// Now encode our override
+						encodeInstruction(resultEncoder, addr, patchedOps, fallthruOffset, 0, addrfactory);
+						int overrideSize = resultEncoder.size();
+						Msg.debug(this, "P-code override: Encoded override for " + addr + " successfully");
+						Msg.debug(this, "P-code override:   Original encoding size: " + origSize + " bytes");
+						Msg.debug(this, "P-code override:   Override encoding size: " + overrideSize + " bytes");
+
+						// Dump the pcode ops we're encoding for verification
+						Msg.debug(this, "P-code override:   Patched ops:");
+						for (int i = 0; i < patchedOps.length; i++) {
+							PcodeOp op = patchedOps[i];
+							StringBuilder sb = new StringBuilder();
+							sb.append("     [").append(i).append("] ");
+							sb.append(op.getMnemonic()).append(" (opcode=").append(op.getOpcode()).append(")");
+							if (op.getOutput() != null) {
+								sb.append(" out=").append(op.getOutput());
+							}
+							sb.append(" inputs=[");
+							for (int j = 0; j < op.getNumInputs(); j++) {
+								if (j > 0) sb.append(", ");
+								sb.append(op.getInput(j));
+							}
+							sb.append("]");
+							Msg.debug(this, "P-code override:" + sb);
+						}
+					} catch (Exception e) {
+						Msg.error(this, "P-code override: ENCODING FAILED for " + addr + ": " + e.getMessage(), e);
+					}
+					return;
+				}
+			}
+
 			instr.getPrototype()
 					.getPcodePacked(resultEncoder, instr.getInstructionContext(),
-						new InstructionPcodeOverride(instr));
+						new AnnotationPcodeOverride(instr, pcodecompilerspec));
 			return;
 		}
 		catch (UsrException e) {
@@ -244,6 +768,55 @@ public class DecompileCallback {
 		resultEncoder.clear();	// Make sure the result is empty
 	}
 
+	/**
+	 * Get overridden P-code for an instruction if an override is registered.
+	 * @param addr the instruction address
+	 * @param instr the instruction
+	 * @return overridden PcodeOp array, or null if no override exists
+	 */
+	private PcodeOp[] getPatchedPcode(Address addr, Instruction instr) {
+
+		// Look up override for this function
+		long funcOffset = funcEntry.getOffset();
+		Map<Long, List<String>> funcOverrides = pcodeOverrides.get(funcOffset);
+		if (funcOverrides == null) {
+			return null;
+		}
+
+		// Check for override at this instruction address
+		long addrOffset = addr.getOffset();
+		List<String> pcodeLines = funcOverrides.get(addrOffset);
+		if (pcodeLines == null || pcodeLines.isEmpty()) {
+			// Log once per function that we found it but this instruction has no override
+			Msg.trace(this, "P-code override: func=0x" + Long.toHexString(funcOffset) + " found, instr=0x" + Long.toHexString(addrOffset) + " no override (have: " + funcOverrides.keySet() + ")");
+			return null;
+		}
+
+		// Parse the pcode operations
+		List<PcodeOp> ops = new ArrayList<>();
+		int seqNum = 0;
+		for (String line : pcodeLines) {
+			PcodeOp op = parsePcodeOp(line, addr, seqNum++, addrfactory);
+			if (op != null) {
+				ops.add(op);
+			}
+		}
+		if (ops.isEmpty()) {
+			return null;
+		}
+
+		// Print each parsed op
+		Msg.info(this, "P-code override: Using override for " + addr + " (" + ops.size() + " ops)");
+		for (int i = 0; i < ops.size(); i++) {
+			PcodeOp op = ops.get(i);
+			Msg.debug(this, "P-code override:   op[" + i + "] opcode=" + op.getOpcode() +
+				" mnemonic=" + op.getMnemonic() +
+				" output=" + (op.getOutput() != null ? op.getOutput().toString() : "null") +
+				" inputs=" + op.getNumInputs());
+		}
+		return ops.toArray(new PcodeOp[0]);
+	}
+
 	/**
 	 * Encode a list of pcode, representing an entire Instruction, to the stream
 	 * 
@@ -720,6 +1293,9 @@ public class DecompileCallback {
 		int extrapop = getExtraPopOverride(func, addr);
 		hfunc.grabFromFunction(extrapop, false, (extrapop != default_extrapop));
 
+		// Check if we have an annotation-based callfixup for this function
+		applyAnnotationCallfixup(func, hfunc);
+
 		HighSymbol funcSymbol = new HighFunctionSymbol(addr, 2, hfunc);
 		Namespace namespc = funcSymbol.getNamespace();
 		if (debug != null) {
@@ -903,6 +1479,9 @@ public class DecompileCallback {
 				hfunc.grabFromFunction(extrapop, includeDefaultNames,
 					(extrapop != default_extrapop));
 
+				// Check if we have an annotation-based callfixup for this function
+				applyAnnotationCallfixup(func, hfunc);
+
 				HighSymbol functionSymbol = new HighFunctionSymbol(entry, (int) (diff + 1), hfunc);
 				Namespace namespc = functionSymbol.getNamespace();
 				if (debug != null) {
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileProcess.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileProcess.java
index 57a1818454..6cd5198c53 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileProcess.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileProcess.java
@@ -699,6 +699,65 @@ public class DecompileProcess {
 		}
 	}
 
+	/**
+	 * Register per-function decompiler fixes.
+	 * @param flags the fix flags to apply (see DecompilerFixFlags in C++)
+	 * @param addresses array of function entry addresses to register
+	 * @param response container for the result
+	 * @throws IOException for problems with the pipe
+	 * @throws DecompileException for problems executing the command
+	 */
+	public synchronized void sendSetDecompilerFixes(int flags, long[] addresses, ByteIngest response)
+			throws IOException, DecompileException {
+		if (!statusGood) {
+			throw new IOException("setDecompilerFixes called on bad process");
+		}
+		paramDecoder = null;
+		resultEncoder = null;
+		try {
+			write(command_start);
+			writeString("setDecompilerFixes");
+			writeString(Integer.toString(archId));  // Sent for protocol compatibility
+			writeString(Integer.toString(flags));
+			writeString(Integer.toString(addresses.length));
+			for (long addr : addresses) {
+				writeString(Long.toHexString(addr));
+			}
+			write(command_end);
+			readResponse(response);
+		}
+		catch (IOException e) {
+			statusGood = false;
+			throw e;
+		}
+	}
+
+	/**
+	 * Clear all registered decompiler fixes.
+	 * @param response container for the result
+	 * @throws IOException for problems with the pipe
+	 * @throws DecompileException for problems executing the command
+	 */
+	public synchronized void sendClearDecompilerFixes(ByteIngest response)
+			throws IOException, DecompileException {
+		if (!statusGood) {
+			throw new IOException("clearDecompilerFixes called on bad process");
+		}
+		paramDecoder = null;
+		resultEncoder = null;
+		try {
+			write(command_start);
+			writeString("clearDecompilerFixes");
+			writeString(Integer.toString(archId));  // Sent for protocol compatibility
+			write(command_end);
+			readResponse(response);
+		}
+		catch (IOException e) {
+			statusGood = false;
+			throw e;
+		}
+	}
+
 	// Calls from the decompiler
 
 	private void getRegister() throws IOException, DecoderException {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/FunctionPrototype.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/FunctionPrototype.java
index e7c84c2e7b..fc2812b8a4 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/FunctionPrototype.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/FunctionPrototype.java
@@ -37,6 +37,15 @@ public class FunctionPrototype {
 	private LocalSymbolMap localsyms; // Prototype backed by symbol map
 	private String modelname; // Name of prototype model
 	private String injectname; // Name of pcode inject associated with this prototype
+
+	/**
+	 * Set the callfixup (inject) name for this prototype.
+	 * This can be used to override or set the callfixup after grabFromFunction().
+	 * @param name the callfixup name, or null to clear
+	 */
+	public void setInjectName(String name) {
+		this.injectname = name;
+	}
 	private DataType returntype; // Output parameter
 	private VariableStorage returnstorage;	// Where the output value is stored
 	private ParameterDefinition[] params; // Internally backed prototype. Only non-null if localsyms is null
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java
index 5f614b6ad8..002b163929 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java
@@ -20,7 +20,9 @@ import static ghidra.program.model.pcode.ElementId.*;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import ghidra.program.database.function.FunctionDB;
 import ghidra.program.database.symbol.CodeSymbol;
@@ -42,6 +44,64 @@ public class HighFunction extends PcodeSyntaxTree {
 	public final static String DECOMPILER_TAG_MAP = "decompiler_tags";
 	public final static String OVERRIDE_NAMESPACE_NAME = "override";
 
+	// ========== PROTO OVERRIDE REGISTRATION ==========
+	// Static registry for prototype overrides: call site address offset -> FunctionSignature
+	// This allows injecting proto overrides without modifying the database,
+	// similar to how callfixups work in DecompileCallback.
+	private static Map<Long, FunctionSignature> registeredProtoOverrides = new HashMap<>();
+
+	/**
+	 * Register a prototype override for a specific call site address.
+	 * The override will be applied during decompilation without modifying the database.
+	 * @param callAddr the address of the call instruction (as long offset)
+	 * @param signature the FunctionSignature to use at this call site
+	 */
+	public static void registerProtoOverride(long callAddr, FunctionSignature signature) {
+		registeredProtoOverrides.put(callAddr, signature);
+	}
+
+	/**
+	 * Register a prototype override using an Address object.
+	 * @param callAddr the address of the call instruction
+	 * @param signature the FunctionSignature to use at this call site
+	 */
+	public static void registerProtoOverride(Address callAddr, FunctionSignature signature) {
+		registeredProtoOverrides.put(callAddr.getOffset(), signature);
+	}
+
+	/**
+	 * Clear all registered prototype overrides.
+	 */
+	public static void clearProtoOverrides() {
+		registeredProtoOverrides.clear();
+	}
+
+	/**
+	 * Get the number of registered prototype overrides.
+	 * @return count of registered overrides
+	 */
+	public static int getRegisteredProtoOverrideCount() {
+		return registeredProtoOverrides.size();
+	}
+
+	/**
+	 * Check if any prototype overrides are registered.
+	 * @return true if overrides are registered
+	 */
+	public static boolean hasRegisteredProtoOverrides() {
+		return !registeredProtoOverrides.isEmpty();
+	}
+
+	/**
+	 * Get all registered prototype overrides.
+	 * @return map of call address offsets to FunctionSignature overrides
+	 */
+	public static Map<Long, FunctionSignature> getRegisteredProtoOverrides() {
+		return registeredProtoOverrides;
+	}
+
+	// ========== END PROTO OVERRIDE REGISTRATION ==========
+
 	private Function func; // The traditional function object
 	private Language language;
 	private CompilerSpec compilerSpec;
@@ -462,20 +522,43 @@ public class HighFunction extends PcodeSyntaxTree {
 			}
 			encoder.closeElement(ELEM_JUMPTABLELIST);
 		}
-		boolean hasOverrideTag = ((protoOverrides != null) && (protoOverrides.size() > 0));
+		// Check for both DB overrides and registered overrides
+		boolean hasDbOverrides = (protoOverrides != null) && (protoOverrides.size() > 0);
+		boolean hasRegisteredOverrides = hasRegisteredProtoOverrides();
+		boolean hasOverrideTag = hasDbOverrides || hasRegisteredOverrides;
 		if (hasOverrideTag) {
 			encoder.openElement(ELEM_OVERRIDE);
 			PcodeDataTypeManager dtmanage = getDataTypeManager();
 			Program prog = func.getProgram();
-			for (DataTypeSymbol sym : protoOverrides) {
-				Address addr = sym.getAddress();
-				int firstVarArg = HighFunctionDBUtil.getFirstVarArg(prog, addr);
-				FunctionPrototype fproto = new FunctionPrototype(
-					(FunctionSignature) sym.getDataType(), compilerSpec, false);
-				encoder.openElement(ELEM_PROTOOVERRIDE);
-				AddressXML.encode(encoder, addr);
-				fproto.encodePrototype(encoder, dtmanage, firstVarArg);
-				encoder.closeElement(ELEM_PROTOOVERRIDE);
+			AddressFactory addrFactory = prog.getAddressFactory();
+
+			// Encode DB overrides first
+			if (hasDbOverrides) {
+				for (DataTypeSymbol sym : protoOverrides) {
+					Address addr = sym.getAddress();
+					int firstVarArg = HighFunctionDBUtil.getFirstVarArg(prog, addr);
+					FunctionPrototype fproto = new FunctionPrototype(
+						(FunctionSignature) sym.getDataType(), compilerSpec, false);
+					encoder.openElement(ELEM_PROTOOVERRIDE);
+					AddressXML.encode(encoder, addr);
+					fproto.encodePrototype(encoder, dtmanage, firstVarArg);
+					encoder.closeElement(ELEM_PROTOOVERRIDE);
+				}
+			}
+
+			// Encode registered overrides (injected without DB modification)
+			if (hasRegisteredOverrides) {
+				for (Map.Entry<Long, FunctionSignature> entry : registeredProtoOverrides.entrySet()) {
+					long addrOffset = entry.getKey();
+					FunctionSignature sig = entry.getValue();
+					Address addr = addrFactory.getDefaultAddressSpace().getAddress(addrOffset);
+					int firstVarArg = HighFunctionDBUtil.getFirstVarArg(prog, addr);
+					FunctionPrototype fproto = new FunctionPrototype(sig, compilerSpec, false);
+					encoder.openElement(ELEM_PROTOOVERRIDE);
+					AddressXML.encode(encoder, addr);
+					fproto.encodePrototype(encoder, dtmanage, firstVarArg);
+					encoder.closeElement(ELEM_PROTOOVERRIDE);
+				}
 			}
 			encoder.closeElement(ELEM_OVERRIDE);
 		}
